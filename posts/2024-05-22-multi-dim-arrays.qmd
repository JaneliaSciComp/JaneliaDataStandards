---
title: "Multi-dimensional array indexing"
description: "Post description"
author: "John Bogovic"
date: "5/10/2024"
---

## Recommendations and summary

Conventions for indexing and storing multi-dimensional data vary across programming languages and software libraries. 
To make data and metadata sharing seamless, software and storage formats should clearly and explicitly communicate:

1. the relationship of array indexes to memory layout
2. the semantic meaning of array dimensions
3. the relationship of coordinate data to array dimensions

Recommendations (1) and (2) may be achieved either by referring to array dimensions in a clear and consistent order or with 
labels that are independent of order (e.g. `['x', 'y', 'z', 't', ...]`, see [xarray](https://docs.xarray.dev/en/latest/getting-started-guide/why-xarray.html))

Recommendation (3) should be achieved by explicitly documenting the array indexing convention (most often C-order or F-order).

## Multi-dimensional array indexing and memory layout

Elements of an n-dimensional array are indexed by an ordered n-tuple, each element of which indexes into one of the array's
dimensions. We will also call elements of this tuple "indexes." For example, the tuple `(i,j,k)` indexes a three-dimensional
array where `i` is the "first" index, and `k` is the "last" index. Here, we will consider only the non-negative integers as
valid indexes for arrays, though different contexts may use a different index set.

Multi-dimensional arrays are often stored as one-dimensional (1D), or "flat," arrays that are interpreted, or "reshaped," into
a multi-dimensional array by mapping the n-tuple of coordinates to a single index into the 1D array. The two most common
conventions for this mapping are C-order and F-order.

In this article, we will refer to n-dimensional arrays as simply "arrays" and 1D arrays as "flat."


#### Reshaping arrays and stride

One can think of reshaping a 1D array as a recursive process of grouping a number of adjacent elements. An n-dimensional array
can be reshaped to an (n+1)-dimensional array by grouping a number adjacent elements belonging to the same dimension. 

* **Define:** the *stride* of a dimension is the (positive) step in the flat array that corresponds to the adjacent element
  along that dimension.

The stride of a dimension is the product of sizes of all previous dimensions. 

* **Define:** the "fastest" or "inner" dimension is the dimension with a stride of 1.
* **Define:** the "slowest" or "outer" dimension is the dimension with the largest stride.

* **Define:** the *size* of a dimension is the number of grouped elements.

The size of an n-dimensional array is described by a list of sizes per dimension. For example: `[3, 5, 7].` In this example,
the *first* dimension has size `3`, the *last* dimension has size `7`.

::: {.callout-tip collapse="true" appearance="minimal"}
# Example 1

Suppose we have this flat array:

`[0, 1, 2, 3, 4, 5]`

and two dimensions having sizes 3 and 2. The first stride is always 1.  The second stride is the previous dimensions' size: 3 in
this example. So our strides are 1 and 3. There is no grouping to be done for a dimensions of stride one, so the first and only
step is to group elements into groups of 3 (the larger stride):

`[(0, 1, 2), (3, 4, 5)]`

:::

::: {.callout-tip collapse="true" appearance="minimal"}
# Example 2

Suppose we have this flat array:

`[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]`


and three dimensions having sizes 2, 3, and 4. Their strides are 1, 2, and 6 where `2*3 = 6`. There is no grouping to be done
for a dimensions of stride 1, so the first step is to join elements into groups of 2 (the second stride):

`[(0, 1), (2, 3), (4, 5), (6, 7), (8, 9), (10, 11), (12, 13), (14, 15), (16, 17), (18, 19), (20, 21), (22, 23)]`

Next, group elements of the new list (which are themselves groups) into groups of 3 (the largest stride).

`[((0, 1), (2, 3), (4, 5)), ((6, 7), (8, 9), (10, 11)), ((12, 13), (14, 15), (16, 17)), ((18, 19), (20, 21), (22, 23))]`

Notice:
* The element adjacent to `0` in the inner group is `1`, hence stride `1`.
* The element adjacent to `0` in the intermediate grouping is `2`, hence stride `2`.
* The element adjacent to `0` in the outer grouping is `6`, hence stride `6`.
:::


### C- and F-order

The terms C-order and F-order come from conventions for indexing arrays in the C and Fortran programming languages.

**TODO** example

If this array is indexed using C-order, then the last index has stride `1`. As a result, the middle index will have stride `7`,
and the *first* dimension will have stride `7*5 = 35`. 

Consider again an array of size `[3, 5, 7]`, but using F-order indexing. Again, the *first* dimension has size `3`, the *last*
dimension has size `7`. Now, however, using F-order, the *first* dimension will have stride `1`, the *second* dimension will
have stride `3`, and the *third* dimension will have stride `3*5 = 15`.

## Dimension semantics

The dimensions of a multi-dimensional array sometimes come with additional semantics depending 
on what data they store. We discuss interpreting arrays as matrices and images.

### Matrices

Matrices are often represented as a 2D array of numbers. Horizontal groupings of these numbers are called "rows" and vertical
groupings are called "columns." In mathematics, the entries of a matrix $A$ are denoted $a_{ij}$. 

::: {.callout-note appearance="minimal"}
# Matrix indexing convention

The first index of a matrix ($i$) refers to rows, the second index ($j$) refers to columns.
:::

::: {.callout-tip collapse=true appearance="minimal"}
# Row- and column-major

The terms row- and column-major derive for the storage of matrices. Defining these terms first depends on first agreeing which
index (first or last) refers to rows vs columns for matrices in mathematics.

* **Consequence:** Given matrix indexing conventions, C-order storage is equivalent to "row-major".
* **Consequence:** Given matrix indexing conventions, F-order storage is equivalent to "column-major".

#### example 

As a result of the *Matrix Indexing Convention* the size of a matrix with `2` rows and `3` columns is `[2, 3]` for both C- and
F-orderings.  Consider:

```
          column 0   column 1   column 2
  row 0  [    0          1          2   ]
  row 1  [    3          4          5   ]
```

* The flat C-ordered array will be: `[0, 1, 2, 3, 4, 5]`
* The flat F-ordered array will be: `[0, 3, 1, 4, 2, 5]`

To reiterate, the multi-dimensional indexes for both C- and F-order are:

```
          column 0   column 1   column 2
  row 0  [  (0,0)     (0,1)       (0,2) ]
  row 1  [  (1,0)     (1,1)       (1,2) ]
```

because, the row index is *always* the first index.

:::

For matrices, C- and F- order indexing will agree on the ordering of an array's indexes and dimensions, but will store the
arrays differently when flattened. This is because the matrix indexing convention attaches semantics (row/column) to
the index position (first/second).

### Images

Typically, 2D images are stored as arrays where two dimensions vary the horizontal and vertical positions of the samples, and as
a result these dimensions should be displayed horizontally and vertically, respectively.  Most formats for storing "natural"
images store data such that the "horizontal axis" / rows have a smaller stride than the "vertical axis" / columns. Note: while
rows have smaller stride than columns, it is common for rows not to have stride 1, for example when using "interleaved" color
components, the "color" dimension will have a stride of 1.

Biomedical images do not typically have "horizonal" or "vertical" dimensions, but may have other semantics (e.g., anatomical, or
related to the imaging system). Software and storage formats should not use stride as a proxy for the semantics of a dimension.

For images, C- and F-order will historically disagree on the ordering of an array's indexes and dimensions, but will store the
arrays the same way when flattened. This is because the convention for natural images historically 
associates dimension semantics to the memory layout (the fastest dimension has horizontal semantics).

## Coordinate data

Coordinate data are data that refer to "locations" of the multidimensional array. They may be discrete, 
and refer to specific samples, or continuous, refering to points "in-between" array locations.

::: {.callout-tip collapse="true" appearance="minimal"}
# Coordinate data examples

* Point annotations
    * "Structure `A` is located at point `(x,y)`"
* Bounding boxes / ROIs
    * "Crop the image to bounding box `(min_x, min_y, width, height)`
* Other collections of points
    * "My neuron skeleton consists of points `[[z0, y0, x0], ..., [zN, yN, xN]]`

:::




### cartesian coordinates

In contrast to the matrix row/column index convention, cartesian
coordinates label the horizontal and vertical dimensions `x` and `y`,
respectively. Referencing positions in the 2D plane is done using
ordered two-tuples `(x,y)`, where `x` is conventionally the left-index
and `y` is the right-index. Using cartesian coordinates, varying
the left dimensions varies horizontal position, and varying the right
dimension varies the vertical position.

Applications and workflows that make use of image geometry most commonly use cartesian coordinates.

## Definitions

#### **Size** (of a dimension)
The number of unique indexes for a dimension.

#### **Stride** (of a dimension)
The (positive) step in the flat array that corresponds to the adjacent element along that dimension.

#### **C-order indexing** 
Tuples for indexing multi-dimensional arrays are ordered such that the **last** coordinate has stride 1.

#### **F-order indexing** 
Tuples for indexing multi-dimensional arrays are ordered such that the **first** coordinate has stride 1.

#### **Fastest dimension** ("inner")
The fastest (or inner) dimension of an array has stride 1

#### **Slowest dimension** ("outer")
The slowest (or outer) dimension of an array with the largest stride.

#### **Row-major**
Arrays storing matrices in “row-major” store adjacent elements in the same row in adjacent memory. This is equivalent to saying
that the column dimension has stride 1.

#### **Column-major**
Arrays storing matrices in “column-major” store adjacent elements in the same column in adjacent memory. This is equivalent to
saying that the row dimension has stride 1.


## References

1) [hdf5 dataspaces](https://docs.hdfgroup.org/hdf5/develop/_h5_s__u_g.html#sec_dataspace)
2) [zarr arrays](https://zarr-specs.readthedocs.io/en/latest/v2/v2.0.html#arrays)
3) [nrrd axis ordering](https://teem.sourceforge.net/nrrd/format.html#general.4)
4) [n5 ordering discussion](https://github.com/saalfeldlab/n5/issues/31)
5) [multi-dimensional arrays in vigra](http://ukoethe.github.io/vigra/doc-release/vigranumpy/index.html#more-on-the-motivation-and-use-of-axistags)

## Appendix

### Programming languages

| C-order | F-order |
| ------- | ------- |
| C       | Fortran |
| C++     | Java    |
| Python  | Matlab  |

### Related terms

| C-order               | F-order                  |
| --------------------- | ------------------------ |
| lexicographical order | co-lexicographical order |
| row-major             | column-major             |
| matrix indexing       | cartesian indexing       |
